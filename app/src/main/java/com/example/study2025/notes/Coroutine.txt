Coroutines

- Coroutines are lightweight threads used for asynchronous programming in Kotlin.
- They help manage background tasks efficiently without blocking the main thread.

---------------------------------------------------------------------------------
Key Concepts of Coroutines in Android

1. Coroutine Scope â€“ Defines the lifecycle of coroutines. Common scopes in Android:
- viewModelScope â†’ Tied to ViewModel, cancels when ViewModel is cleared.
- lifecycleScope â†’ Tied to a LifecycleOwner (like an Activity or Fragment).
- GlobalScope â†’ Lives throughout the app's lifecycle (use cautiously).

2. Coroutine Dispatchers â€“ Determines where/which thread the coroutine runs:
- Dispatchers.Main â†’ Runs on the UI thread (for UI updates).
- Dispatchers.IO â†’ Optimized for disk/network I/O operations.
- Dispatchers.Default â†’ Used for CPU-intensive tasks.
- Dispatchers.Unconfined â†’ Starts in the caller thread but may switch.

3. Suspend Functions (suspend)
â€“ Functions that can be paused and resumed without blocking the thread.
- Can only be called from another suspend function or coroutine.

4. Launch vs Async â€“ Ways to start coroutines:
- launch {} â†’ Fire-and-forget, doesn't return a result.
- async {} â†’ Returns a Deferred<T> (future result), can be awaited using .await().

val job = launch { println("Launch: No result returned") }
val result = async { 10 + 20 }
println("Async result: ${result.await()}")

---------------------------------------------------------------------------------

1. Dispatchers.Main (UI Thread)
- Used for updating UI elements. If you try to run heavy operations here, the app may freeze.
ðŸ”¹ Use cases: UI updates, lightweight tasks like showing Toasts, setting text, etc.

class MyViewModel : ViewModel() {
    fun updateUI() {
        viewModelScope.launch(Dispatchers.Main) {
            textView.text = "Hello, Coroutines!" // Runs on the main thread
        }
    }
}

2. Dispatchers.IO (Background Thread for I/O operations)
- Used for disk and network operations like database queries or API calls.
ðŸ”¹ Use cases: Fetching data from Room database, network calls, file I/O.

viewModelScope.launch(Dispatchers.IO) {
    val data = fetchFromNetwork() // Runs in the background
    withContext(Dispatchers.Main) {
        textView.text = data // Switches to the UI thread
    }
}


3. Dispatchers.Default (Background Thread for CPU-intensive tasks)
- Used for tasks that require heavy computation, like sorting large lists, processing images, or encrypting data.
ðŸ”¹ Use cases: Data processing, JSON parsing, complex calculations

viewModelScope.launch(Dispatchers.Default) {
    val sortedList = myList.sorted() // Runs on a background thread
    withContext(Dispatchers.Main) {
        textView.text = "Sorting Done!" // Switches to UI thread
    }
}

4. Dispatchers.Unconfined (Runs on the Callerâ€™s Thread (may change the thread))


- Use Main for UI updates.
- Use IO for database and network operations.
- Use Default for CPU-intensive tasks.
- Avoid Unconfined unless absolutely needed.

---------------------------------------------------------------------------------
Can we switch between dispatchers in a coroutine?
- Yes, using withContext().

How does structured concurrency help avoid memory leaks?
- Coroutines are bound to a CoroutineScope, so if the scope (like viewModelScope) is canceled, all child coroutines get canceled automatically.

How do you handle exceptions in coroutines?
- Use try-catch, CoroutineExceptionHandler

How can you cancel a coroutine?
- job.cancel().
val job = launch {
    repeat(1000) { i ->
        if (!isActive) return@launch
        println("Printing $i")
        delay(500)
    }
}
delay(2000)
job.cancel() // Cancels coroutine


---------------------------------------------------------------------------------
Coroutine Scope vs Supervisor Scope

coroutineScope {}
- If one child coroutine fails, all sibling coroutines are canceled.
suspend fun fetchData() = coroutineScope {
    launch {
        delay(1000)
        throw RuntimeException("Network error") // Cancels all other coroutines
    }
    launch {
        delay(2000)
        println("This won't execute if first launch fails")
    }
}

supervisorScope {} (Independent Failures)
- If one coroutine fails, others continue executing.
- Use supervisorScope for independent tasks that should not affect each other.
suspend fun fetchData() = supervisorScope {
    launch {
        delay(1000)
        throw RuntimeException("Network error") // Other coroutines keep running
    }
    launch {
        delay(2000)
        println("This still executes despite failure")
    }
}





















































